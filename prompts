#!/bin/sh vim: foldlevel=0

# Prompt functions {{{1
if test -n "$BASH"; then
# prompt_detached: Determine number of detached screen/tmux sessions {{{2
prompt_detached () {
    local n_screen=$(screen -ls 2> /dev/null | grep -c '[Dd]etach[^)]*)$')
    local n_tmux=$(tmux list-sessions 2> /dev/null | grep -cv attached)
    local detached=$(( $n_screen + $n_tmux ))
    if [[ $detached != "0" ]]; then
        printf "%sd" "${detached}"
    fi
}
# prompt_jobs: Get running and stopped jobs {{{2
# Only works under Bash
prompt_jobs () {
    printf "%s&/%sz" $( jobs -r | wc -l | tr -d " " ) $( jobs -s | wc -l | tr -d " " )
}
# prompt_load: Get system load {{{2
prompt_load () {
    local one=
    local five=
    local rest=
    read one five rest < /proc/loadavg
    printf "%s:%s" "$one" "$five"
}

# prompt_uptime: Get uptime {{{2
prompt_uptime () {
    local uptime=$(</proc/uptime)
    uptime=${uptime%%.*}

    local mins=$(( uptime/60%60 ))
    local hours=$(( uptime/60/60%24 ))
    local days=$(( uptime/60/60/24 ))

    if [ "$days" -ne "0" ]
    then
        printf "%sd " "${days}"
    fi
    printf "%s:%s" "${hours}" "${mins}"
}

# prompt_user: Determine if root or not logged in user {{{2
prompt_user () {
    if [ "x$EUID" = 'x0' ]; then
        printf "%s" 'root'
    elif [ $USER != `logname 2>/dev/null` ]; then
        printf "su to %s" "$USER"
    else
        printf "%s" $USER
    fi
}

# prompt_ssh: Determine if running under ssh {{{2
prompt_ssh () {
    if [ -n "$SSH_CLIENT$SSH2_CLIENT$SSH_TTY" ]; then
        printf "%s" 'ssh'
    else
        printf "%s" 'local'
    fi
}

# prompt_tty: Get tty {{{2
prompt_tty () {
    tty | sed -e 's:/dev/::'
}

# prompt_pwd: Print pwd with colors {{{2
#
# prompt_pwd modified from Yu-Jie Lin's example <libb.wordpress.com>
#
# Arguments:
#   $1 : directory color
#   $2 : slash color
prompt_pwd () {
    local dir_clr=$1
    local slash_clr=$2
    local pwd=$PWD
    pwd=${pwd/#$HOME/\~}
    echo ${pwd//\//$slash_clr\/$dir_clr}
}

# prompt_error: Print exit value of last command if it is non-zero {{{2
#
# prompt_error modified from Yu-Jie Lin's example <libb.wordpress.com>
#
# Arguments:
#   $1: output color
prompt_error () {
    local error_clr=$1

    if [ $RETVAL -gt 0 ]; then (( i = 3 - ${#RETVAL} ));
        printf "%s" "$error_clr[";
        [ $i -gt 0 ] && printf "%s" " ";
        printf "%s" "$RETVAL";
        [ $i -eq 2 ] && printf "%s" " ";
        printf "%s" "]$(FX reset)";
    fi
}

# prompt_git: Print current git branch and the following status codes: {{{2
#  +    Uncommitted changes
#  !    Unstaged changes
#  ?    Untracked files
#  $    Stashed files
#
#
# Arguments:
#   $1: String to print immediately before branch name
#   $2: String to print immediately after branch name
#   $3: String to print immediately after repo status
prompt_git() {
	local s=''
	local branchName=''

	# Check if the current directory is in a Git repository.
	git rev-parse --is-inside-work-tree &>/dev/null || return

	# Check for what branch we’re on.
	# Get the short symbolic ref. If HEAD isn’t a symbolic ref, get a
	# tracking remote branch or tag. Otherwise, get the
	# short SHA for the latest commit, or give up.
	branchName=$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
		git describe --all --exact-match HEAD 2> /dev/null || \
		git rev-parse --short HEAD 2> /dev/null || \
		printf '%s' '(unknown)')

    # Check for uncommitted changes in the index.
    if ! $(git diff --quiet --ignore-submodules --cached); then
        s+='+'
    fi;
    # Check for unstaged changes.
    if ! $(git diff-files --quiet --ignore-submodules --); then
        s+='!'
    fi;
    # Check for untracked files.
    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
        s+='?';
    fi;
    # Check for stashed files.
    if $(git rev-parse --verify refs/stash &>/dev/null); then
        s+='$';
    fi;

	[ -n "${s}" ] && s=" ${s}";

	echo -e "${1}${branchName}${2}${s}${3}";
}

fi # End bash-specific section
# Prompt color definitions {{{1
#

# Determine if terminal supports color
#
test $( tput colors ) -ge 0 && HAS_COLOR=yes

if test $HAS_COLOR; then
    dir_clr="\[$(FX reset; FG 2)\]"
    slash_clr="\[$(FX reset; FG 1)\]"
    git_branch_clr="\[$(FX bold; FG 4)\]"
    git_status_clr="\[$(FX bold; FG 3)\]"
    user_clr="\[$(FX reset; FG 6)\]"
    root_user_clr="\[$(FX reset; FG 1)\]"
    at_clr="\[$(FX reset; FG 4)\]"
    hostname_clr="\[$(FX reset; FG 5)\]"
    ssh_clr="\[$(FX bold; FG 3)\]"
    jobs_clr="\[$(FX reset; FG 7)\]"
    history_clr="\[$(FX reset; FG 2)\]"
    error_clr="\[$(FX reset; FG 7; BG 1)\]"
    prompt_clr="\[$(FX reset; FG 3)\]"
    bracket_clr="\[$(FX bold; FG 4)\]"
    reset="\[$(FX reset)\]"

    # Colorize username differently if we are root
    test "$UID" = "0" && user_clr=$root_user_clr

    # Strip the non-printing escapes if not running in bash {{{
    if test -z "$BASH"; then 
        dir_clr=${dir_clr#\\[}
        slash_clr=${slash_clr#\\[}
        git_branch_clr=${git_branch_clr#\\[}
        git_status_clr=${git_status_clr#\\[}
        user_clr=${user_clr#\\[}
        root_user_clr=${root_user_clr#\\[}
        at_clr=${at_clr#\\[}
        hostname_clr=${hostname_clr#\\[}
        ssh_clr=${ssh_clr#\\[}
        jobs_clr=${jobs_clr#\\[}
        history_clr=${history_clr#\\[}
        error_clr=${error_clr#\\[}
        prompt_clr=${prompt_clr#\\[}
        bracket_clr=${bracket_clr#\\[}
        reset=${reset#\\[}
        dir_clr=${dir_clr%\\]}
        slash_clr=${slash_clr%\\]}
        git_branch_clr=${git_branch_clr%\\]}
        git_status_clr=${git_status_clr%\\]}
        user_clr=${user_clr%\\]}
        root_user_clr=${root_user_clr%\\]}
        at_clr=${at_clr%\\]}
        hostname_clr=${hostname_clr%\\]}
        ssh_clr=${ssh_clr%\\]}
        jobs_clr=${jobs_clr%\\]}
        history_clr=${history_clr%\\]}
        error_clr=${error_clr%\\]}
        prompt_clr=${prompt_clr%\\]}
        bracket_clr=${bracket_clr%\\]}
        reset=${reset%\\]}
    fi # }}}
else
    dir_clr=
    slash_clr=
    user_clr=
    root_user_clr=
    at_clr=
    hostname_clr=
    ssh_clr=
    jobs_clr=
    history_clr=
    error_clr=
    prompt_clr=
    bracket_clr=
    reset=
fi

# Prompts {{{1
# Bash prompt {{{2
if test -n "$BASH"; then
#############################################
# This prompt looks roughly like this:
#
# 'pwd (git branch) [git status]'
# 'user@host (ssh)
# '{jobs} [history] [$?]'
# '$ '
#############################################

PS1="\
$reset\$(prompt_pwd $dir_clr $slash_clr) \$(prompt_git "$git_branch_clr\\\(" "$git_status_clr" "$git_branch_clr\\\)")
$user_clr$(prompt_user)$at_clr@$hostname_clr\h $bracket_clr($ssh_clr$(prompt_ssh)$bracket_clr)
$brackrt_clr{$jobs_clr\$(prompt_jobs)$bracket_clr} $bracket_clr!$history_clr\! \$(prompt_error $error_clr)
$prompt_clr$ $reset"

# Need to save $? here so that ps1_error can occur anywhere in the prompt
# Otherwise, new_pwd will clobber the value of $? that we want
#
# history -a allows multiple shells to write to the same history file
#
PROMPT_COMMAND='RETVAL=$?; history -a'
# sh prompt {{{2
else # End bash / start sh
#############################################
# This prompt looks roughly like this:
#
# 'pwd
# <username@hostname> $'
#############################################

PS1="$reset$dir_clr\$(pwd)
$bracket_clr<$user_clr$(whoami)$at_clr@$hostname_clr$(hostname)$bracket_clr> $prompt_clr$ $reset"
fi # End sh-specific section
# }}}
# Clean up {{{1
 unset dir_clr slash_clr hostname_clr at_clr bracket_clr
 unset history_clr error_clr prompt_clr user_clr root_user_clr
 unset ssh_clr jobs_clr
 unset reset
 unset HAS_COLOR

