#!/bin/sh vim: foldlevel=0
#
# Jeremy Brubaker <jbru362@gmail.com>

# PATH Manipulation Functions {{{

# Usage: pls [<var>]
# List path entries of PATH or environment variable <var>.
pls () {
    eval echo \$${1:-PATH} |tr : '\n';
}

# Usage: pshift [-n <num>] [<var>]
# Shift <num> entries off the front of PATH or environment var <var>.
# with the <var> option. Useful: pshift $(pwd)
pshift () {
    local n=1
    [ "$1" = "-n" ] && { n=$(( $2 + 1 )); shift 2; }
    eval "${1:-PATH}='$(pls |tail -n +$n |tr '\n' :)'"
}

# Usage: ppop [-n <num>] [<var>]
# Pop <num> entries off the end of PATH or environment variable <var>.
ppop () {
    local n=1 i=0
    [ "$1" = "-n" ] && { n=$2; shift 2; }
    while [ $i -lt $n ]
    do eval "${1:-PATH}='\${${1:-PATH}%:*}'"
       i=$(( i + 1 ))
    done
}

# Usage: punshift <path> [<var>]
# Shift <path> onto the beginning of PATH or environment variable <var>.
punshift () {
    eval "${2:-PATH}='$1:$(eval echo \$${2:-PATH})'"
}

# Usage: ppush <path> [<var>]
ppush () {
    eval "${2:-PATH}='$(eval echo \$${2:-PATH})':$1"
}

# Usage: puniq [<path>]
# Remove duplicate entries from a PATH style value while retaining
# the original order. Use PATH if no <path> is given.
#
# Example:
#   $ puniq /usr/bin:/usr/local/bin:/usr/bin
#   /usr/bin:/usr/local/bin
puniq () {
    echo "$1" |tr : '\n' |nl |sort -u -k 2,2 |sort -n |
    cut -f 2- |tr '\n' : |sed -e 's/:$//' -e 's/^://'
}

# Usage: prm <path> [<var>]
# Remove <path> from PATH or environment variable <var>.
prm () {
    eval "${2:-PATH}='$(pls $2 |
        grep -v "^$1\$" |tr '\n' :)'"
}
# }}}
# Color Escape Functions {{{

###################################################
# Functions to set colors and attributes
#
#  $(FX bold) sets bold attribute
#  $(FG 1) sets foreground color to ANSI color 1
#  $(BG 1) sets background color to ANSI color 1
#  $(FX bold; FG 1) sets foreground color to ANSI
#      color 1 and bold in one command
#
# These functions automatically interpret escape
# sequences so you don't need to pass '-e' to echo
#
# Based on P. C. SHyamshankar's spectrum script
# for zsh <github.com/sykora>.
# Changed to use functions instead of hashes for speed
# Changed to use tput(1) as much as possible
###################################################
FX()
{
    case "$1" in
        reset)       tput sgr0 ;;
        bold)        tput bold ;;
        nobold)      echo -en "\e[22m" ;; # no tput sequence
        dim)         tput dim ;;
        nodim)       ;;                   # no tput sequence
        italic)      tput sitm ;;
        noitalic)    tput ritm ;;
        underline)   tput smul ;;
        nounderline) tput rmul ;;
        blink)       tput blink ;;
        fastblink)   echo -en "\e[6m" ;;  # no tput sequence
        noblink)     echo -en "\e[25m" ;; # no tput sequence
        reverse)     tput rev ;;
        noreverse)   echo -en "\e[27m" ;; # no tput sequence
        hidden)      echo -en "\e[8m" ;;  # no tput sequence
        nohidden)    echo -en "\e[28m" ;; # no tput sequence
        standout)    tput smso ;;
        nostandout)  tput rmso ;;
        strikeout)   echo -en "\e[9m" ;;  # no tput sequence
        nostrikeout) echo -en "\e[29m" ;; # no tput sequence

        *)           echo "";
    esac
}

if test $( tput colors ) -ge 0; then
    FG() {
        tput setaf $1
    }

    BG()
    {
        tput setab $1
    }
else
    FG() {
        :
    }

    BG() {
        :
    }
fi

# }}}
# navi {{{
_navi_call() {
    local result="$(navi --path ~/share/navi "$@" </dev/tty)"
    if [ -z "${result}" ]; then
        result="$(navi --path ~/share/navi --print </dev/tty)"
    fi
    printf "%s" "$result"
}

_navi_widget() {
    local -r input="${READLINE_LINE}"
    local -r last_command="$(echo "${input}" | navi fn widget::last_command)"

    if [ -z "${last_command}" ]; then 
        local -r output="$(_navi_call --print --fzf-overrides '--no-select-1')"
    else
        local -r find="$last_command"
        local -r replacement="$(_navi_call --print --query "${last_command}")"
        local -r output="${input//$find/$replacement}"
    fi

    READLINE_LINE="$output"
    READLINE_POINT=${#READLINE_LINE}
}

bind -x '"\C-g": _navi_widget'
# }}}
# Miscellaneous Functions {{{

# rpg-cli {{{
cd () {
    if [ "$#" -eq 0 ]
    then
        rpg-cli "$HOME"
    elif [ "$1" == "-" ]
    then
        rpg-cli "$OLDPWD"
    else
        rpg-cli "$@"
    fi
    builtin cd "$(rpg-cli --pwd)"
}

# }}}

###
# cd
#
# 'cd u..' goes up two directores (one per dot)
#
# https://jip.dev/posts/dots/
#
# TODO: zsh syntax needs fixed
# cd() {
    # if [[ $1 == 'u.'* ]]; then
        # builtin cd ${${1/"b"}//"."/"../"}
    # else
        # builtin cd $*
    # fi
# }

###
# ip
#
# 'ip get' prints current ip address and copies to clipboard
# All other commands are passed to the real 'ip' command
#
# https://jip.dev/posts/dots/
#
# TODO: Doesn't pass args right
# TODO: Option to copy to clipboard?
# ip() {
    # if [[ $1 == 'get' ]]; then
        # res=$(curl -s ipinfo.io/ip)
        # echo -n $res | xsel --clipboard
        # echo "copied $res to clipboard"
    # else
        # only run ip if it exists
        # command ip >/dev/null &&
            # command ip $@
    # fi
# }

###
# lsp
#
# Print numerical permissions at the start of each line
#
# https://github.com/blaenk/dots/blob/master/zsh/zsh/functions.zsh
#
###
lsp ()
{
    command ls -lh --color=always $@ | \
        awk '{k=0;for(i=0;i<=8;i++)k+=((substr($1,i+2,1)~/[rwx]/)\
        *2^(8-i));if(k)printf("%0o ",k);print}'
}

####
# google
#
# Google something
#
# Expects: a google search string, just like
#          you would enter it at the website
####
google ()
{
    # Create search string if arguments were passed
    if [[ "$*" ]]; then
        # Google search strings replace spaces with '+'
        IFS='+'
        local search_string="$*"
        unset IFS

        local url="search?hl=en&lr=&ie=UTF-8&oe=UTF-8&q="
        url="$url$search_string&btnG=Google+Search"
    fi

    # Open URL in browser. If no arguments were passed
    # it merely opens google.com
    openurl "www.google.com/$url"
}

####
# define
#
# Define words and phrases with google
####
define()
{
    local y="$@"
    curl -sA"Opera" "http://www.google.com/search?q=define:${y// /+}"|grep -Eo '<li>[^<]+'|sed 's/^<li>//g'|nl|/usr/bin/perl -MHTML::Entities -pe 'decode_entities($_)'
}

rtfm()
{
    man "$@" || [[ -f "/usr/share/info/$@.info*" ]] && info "$@" ||
        echo "No info entry for $@" >/dev/stderr && "$@" --help ||
        openurl "http://duckduckgo.com/?q=%21man+$@" ;
}

####
# hb/hr/hbl
# Bold, Reverse-Video and Blinking highlighted search
#
# Args:
#  $1 - search string
#  $2 - optional foreground color number
#
# Examples:
# who | hb "$USER" 1 
# ps | hr ".*$PPID.*" | hbl ".*$$.*"
####
hb()
{
    local fg
    test $2 && fg=$( FG $2 )
    sed "s/\($1\)/$(FX bold)$fg\1$(FX reset)/gI"

}

hr()
{
    local fg
    test $2 && bg=$( FG $2 )
    sed "s/\($1\)/$(FX reverse)$bg\1$(FX reset)/gI"
}

hbl()
{
    local fg
    test $2 && fg=$( FG $2 )
    sed "s/\($1\)/$(FX blink)$fg\1$(FX reset)/gI"
}

###
# lh
#
# List last "n" commands in history
###
lh()
{
    history | tail -"$1"
}

###
# manf
#
# https://jip.dev/posts/dots/
#
# Open manpage for $1 at the first occurence
# of flag $2
manf() {
      man -P "less -p \"^ +$2\"" $1
}

###
# tree
#
# Make tree(1) ignore .git, lists directories first, appends filetype character
# and pipes into a pager. Try to use vimpager and fallback to less
tree() {
    local pager='less -FRNX'
    command -v vimpager >/dev/null &&
        pager='vimpager'
	command tree -CFI '.git' --dirsfirst "$@" | $pager
}

###
# wiki
#
# wiki <command> [args ...]
#
# Commands: run wiki help
#
# Requires $WIKI_DIR to be set to wiki root directory
#
# Inspired by: https://vimwiki.github.io/vimwikiwiki/Tips%20and%20Snips.html
wiki() {
    if test -z "$WIKI_DIR"; then
        printf "%s\n" '$WIKI_DIR is not defined'
        return 1
    fi

    case "$1" in
        git)
            git -C "$WIKI_DIR ${@:2}"
            ;;
        make)
            (cd "$WIKI_DIR" && make ${@:2})
            ;;
        view)
            test -n "$2" && BROWSER="$2"
            openurl "$WIKI_DIR/site/index.html"
            ;;
        help)
            cat <<'END'
Usage: wiki <command> [args ...]

Commands:
    edit             Edit $WIKI_DIR/content/index.md in $EDITOR
    git [args]       Pass [args] to git(1) and execute in $WIKI_DIR
    make [args]      Run make(1) [args] in $WIKI_DIR
    view [browser]   Use openurl to view the wiki at $WIKI_DIR/site.
                       Use [browser] to view. Default is $BROWSER
    help             View this help

    Edit is the default command

Note: $WIKI_DIR must be defined
END
            ;;
        edit | *)
            if test -z "$EDITOR"; then
                EDITOR=vim
            fi
            $EDITOR "$WIKI_DIR/content/index.md"
            ;;
        esac
}
# }}}
# Helper Functions {{{
# (prefix names with '__')

