#!/bin/sh
#
# Jeremy Brubaker <jbru362@gmail.com>

# Helper functions {{{1
# NOTE: these are unset at the end of the file
#
# have {{{2
#
# @description Check PATH for a command
#
# @arg $1 str Command to search for
#
# @exitcode true if found
# @exitcode false if not found
#
have() { command -v "$1" >/dev/null; }

# Defaults {{{1
#
# This will be overriden if grc(1) is available
jobs='jobs -l' # list PIDs
alias jobs=$jobs

# grc(1)-only aliases {{{1
#
# Put these first so that they can be overriden
#
if have grc; then
    GRC_OPTS='-es' # colorize stderr and stdout
    grc='grc $GRC_OPTS'
    alias grc=$grc

    # Create alias for all configs found *if* the command exists
    for c in /usr/share/grc/conf.* ~/.grc/conf.*; do
        c=${c##*/}; c=${c#conf.} # extract command name
        have $c && alias $c="$grc $c"
    done

    # Always create these
    alias configure="$grc ./configure"
    alias  printenv="$grc -c conf.printenv printenv"
    alias      jobs="$jobs${BASH:+ | grcat conf.jobs}" # colorized version
    alias   tcpdump="$grc tcpdump -l"

    # If ping gives **no** response, grc will buffer everything
    # until ping is killed. This allows the intial line to be displayed
    # so you know something is actually happening
    have stdbuf &&
        alias ping="$grc -c conf.ping stdbuf -oL ping"
fi

# ls(1) {{{1
#
ls=$LS # defined in ~/.env
case $LS in
    ls) command ls --version | grep -q GNU && ls=gnu-ls ;;
    '') ls=ls ;;
esac

case $ls in
    eza | exa)
        LS_OPTS=$LS_OPTS
        ls_opts='';      ll_opts='-lg';
        la_opts='-a';    lla_opts='-lag';
        ld_opts='-d .*'; lld_opts='-lg -d .*';
        lspa_opts=''
        ;;
    gnu-ls) # GNU ls
        LS_OPTS=$LS_OPTS
        ls_opts='';      ll_opts='-l';
        la_opts='-A';    lla_opts='-lA';
        ld_opts='-d .*'; lld_opts='-l -d .*';
        lspa_opts='-A'
        ;;
    ls) # POSIX ls
        ls_opts='';      ll_opts='-l';
        la_opts='-a';    lla_opts='-la';
        ld_opts='-d .*'; lld_opts='-lg -d .*';
        lspa_opts='-A'
        ;;
    *) printf 'How did we get here?\n' >&2 ;;
esac

# Force color if using grc with an ls that supports color
unset grc_col
if have grc && [ -n "$HAS_COLOR" ] && [ "$ls" = 'gnu-ls' ]; then
    grc_col='--color=always'
fi

# Single-quote $LS_OPTS so it can be changed on the fly
alias   ls="$LS $ls_opts "'$LS_OPTS'
alias   ll="${grc:+"$grc "}$LS $ll_opts "'$LS_OPTS'" $grc_col"
alias   la="$LS $la_opts "'$LS_OPTS'
alias  lla="${grc:+"$grc "} $LS $lla_opts "'$LS_OPTS'" $grc_col"
alias   l.="$LS $ld_opts "'$LS_OPTS'
alias  ll.="${grc:+"$grc "} $LS $lld_opts "'$LS_OPTS'" $grc_col"
alias lspa="lsp $lspa_opts" # lsp is defined in ~/.functions

unset ls ls_opts la_opts ll_opts lla_opts ld_opts lld_opts ldap_opts grc_col

# cd {{{1
#
alias  ..='cd ..'          # up one directory
alias ...='cd ../..'       # up two directories
alias ${BASH:+--} -='cd -' # cd to previous directory

# X-specific {{{1
#
if [ -n "$DISPLAY" ]; then
    # force using vimx so Vim can access the system clipboard
    if have vimx; then
        alias vim=vimx
        alias  vi=vimx
    fi
fi

# OS-specific {{{1
#
case $(uname -o) in
    *) ;;
esac

# Alternatives {{{1
#
alias     term='( $(my terminal)& )'
alias     calc='( $(my calculator)& )'
alias calendar='( $(my calendar)& )'

# Cassowary {{{1
#
if have cassowary; then
    alias word='cassowary -c guest-run winword'
    alias excel='cassowary -c guest-run excel'
    alias ppt='cassowary -c guest-run powerpnt'
    alias mspub='cassowary -c guest-run mspub'
    alias onenote='cassowary -c guest-run onenote'
    alias access='cassowary -c guest-run msaccess'
fi

# PAGER / cat {{{1
#
# - less / zless calls $PAGER
# - syntax highlight cat if possible (depends on *_STYLE variables)
#
case $PAGER in
    vimpager)
        alias  less='vimpager'
        alias zless='vimpager'
        alias   cat='vimcat' ;;
    bat)
        alias  less='bat -p -pager less'
        alias zless='bat -p -pager less'
        alias cat='bat -p --paging never' ;;
    *)
        if [ "$PAGER" != less ]; then
            alias  less=$PAGER
            alias zless=$PAGER
        else
            # NOTE: $LESS is not being passed to less(1)
            alias  less="less $LESS"
            alias zless="less $LESS"
        fi
        if have highlight; then
            cat() {
                # Use cat(1) if no files are given or if redirecting stdout
                # (avoid colors)
                if [ $# -eq 0 ] || ! [ -t 1 ]; then
                    /bin/cat $@
                else
                    # If stdout is the terminal, use highlight but loop through
                    # $@ so it works properly
                    for _a in "$@"; do
                        # Emulate cat(1) ENOENT error message
                        if ! [ -r "$_a" ]; then
                            printf '/bin/cat: %s: No such file or directory\n' "$_a" >&2
                            continue
                        fi
                        highlight --force -O truecolor --style "${HIGHLIGHT_STYLE:-solarized-dark}" "$_a"
                    done
                fi
            }
        elif have bat; then
            cat() {
                # Use cat(1) if no files are given or if redirecting stdout
                # (avoid colors)
                if [ $# -eq 0 ] || ! [ -t 1 ]; then
                    /bin/cat $@
                else
                    for _a in $@; do
                        # Emulate cat(1) ENOENT error message
                        if ! [ -r "$_a" ]; then
                            printf '/bin/cat: %s: No such file or directory\n' "$_a" >&2
                            continue
                        fi
                        bat --decorations never --paging never "$_a"
                    done
                fi
            }
        elif have pygmentize; then
            cat() {
                # Use cat(1) if no files are given or if redirecting stdout
                # (avoid colors)
                if [ $# -eq 0 ] || ! [ -t 1 ]; then
                    /bin/cat $@
                else
                    for _a in $@; do
                        # Emulate cat(1) ENOENT error message
                        if ! [ -r "$_a" ]; then
                            printf '/bin/cat: %s: No such file or directory\n' "$_a" >&2
                            continue
                        fi
                        pygmentize -O style=${PYGMENTIZE_STYLE:-solarized-light} -g "$_a"
                    done
                fi
            }
        fi ;;
esac

# Get public IP & ipinfo.io{{{1
#
if have curl; then
    alias   myip='curl http://ipecho.net/plain; echo'
    alias ipinfo='curl http://ipinfo.io; echo'
elif have wget; then
    alias   myip='wget http://ipecho.net/plain -O - -q; echo'
    alias ipinfo='wget http://ipinfo.io -O - -q; echo'
else
    alias   myip='printf "wget or curl not available\n"'
    alias ipinfo='myip'
fi

# Vim & Ex {{{1
#
alias  minpac_clean='vim +PackCleanAndQuit'          # remove old plugins
alias minpac_update='vim +PackUpdateAndQuit'         # add and update plugins
alias minpac_status='vim +PackStatus +only'          # show plugin status
alias          gist='vim "+Gist -l"'                 # open Gist browser
alias          trim='ex +"bufdo! %s/\s\+$//e" -scxa' # trim trailing whitespace

# Miscellaneous {{{1
#
have reset || alias reset='tput sgr0'  # reset terminal
have clear || alias clear='tput clear' # emulate clear(1) if I don't have it
              alias   cls='clear'      # windows clear

have buku       && alias       b='buku --suggest'             # easier buku
have colormake  && alias    make='colormake'                  # use colormake
have locate     && alias     loc='locate -d "$LOCATEDB" "$@"' # use my personal locate(1) db
have mgitstatus && alias    gits='mgitstatus -e -c'           # get status of git repos
have pandoc     && alias md2html='pandoc -f markdown'         # convert Markdown to HTML
have rpg-cli    && alias     rpg='rpg-cli'                    # easier rpg-cli
have todo.sh    && alias       t='todo.sh'                    # easier todo.sh

alias             +x='chmod +x' # make file executable
alias ${BASH:+--} -x='chmod -x' # make file non-executable 

alias      :q='exit'                                    # exit like it's vim
alias    bell='printf "\a"'                             # ring the bell
alias    grep="grep ${HAS_COLOR:+--color=auto}"         # force color in *grep
alias      nu="who | cut -d' ' -f1 | uniq | wc -l"      # get number of logged on users
alias       r='fc -s'                                   # ^old^new but global
alias    ship='ip --brief address'                      # short IP interface overview
alias    sudo='sudo '                                   # enable aliases to be sudoâ€™ed
alias   tree='command tree -CFI ".git" --dirsfirst'     # better looking tree(1)
alias unexec='find . -type f -exec chmod ogu-x "{}" \;' # chmod -x all FILES in tree (needed when copying from Windows)

# It would be nice if telnet had something like ssh configs
alias rcbb='telnet realitycheckbbs.org -l "Jeremy Brubaker"'

# start / stop a local-only ssh server
if have sshd; then
    alias lsshd='/usr/sbin/sshd -f "$LOCAL_SSHD_CONFIG"' # start a local ssh server
    alias klsshd='kill -TERM $(command cat $(sshd -f "$LOCAL_SSHD_CONFIG" -T | grep pidfile | cut -d" " -f2))'  # stop user sshd
fi

# Use grc(1) if available {{{2
#
alias   df="${grc:+"$grc "}df -hT"              # human-readable is better
alias   du="${grc:+"$grc "}du -h"               # human-readable is better
alias  du1="${grc:+"$grc "}du -h --max-depth=1" # top-level summary
alias free="${grc:+"$grc "}free -h"             # human-readable is better

# Cleanup {{{1
#
unset grc
unset have
unset jobs

# vim: ft=sh foldlevel=0

