#!/usr/bin/perl -w

#Version 0.5, Jan 5 1999: Added the -p and -h options.  Switched over to 
#Getopt::Long for argument processing.

#Version 0.2, Jan 4 1999: Fixed problem where specifying an unknown
#argument would result in an infinite loop.  Thanks to Ketil Froyn
#for notifying me of the bug.

#Version 0.1, Jan 3 1999: Initial version

#Quote of the Day daemon
#version 0.3, by Matthew Sachs <matthewg@interport.net>
#This program's homepage is @ http://www.zevils.com/linux/

#TCP server framework taken from The Perl Cookbook
#Distributed under Version 2 of the GNU Public License
#See http://www.gnu.org for more information or a copy of the license.

#SIGHUP restarts the server - only appliciable when not running in inetd mode.

$cmd = "/usr/games/fortune -s"; #The output of this command is sent to the client

#DON'T CHANGE ANYTHING BELOW THIS LINE!!

$version = "0.5";

sub dispver {
	print "qotdd: Quote of the Day daemon.\nVersion: $version\n";
	exit 0;
}

sub help {
	print <<EOF
qotdd - Quote of the Day Daemon version $version
qotdd sends the output of a command to any client connecting to its port.

Usage: qotdd [-v] [-c command] [-i] [-p port]

You can use either the short or long forms with one or two dashes in
whatever combination you want.  However, you can't combine options like
qotdd -ic uptime

	-h, -?, --help, --usage:	Print this message and exit

	-v, --version:			Shows version and exits

	-c, --command  command:		Use command instead of the default,
					which is fortune -s unless you've 
					changed it

	-i, --inetd:			Use if starting from inetd
					The line in /etc/inetd.conf used to
					start qotdd should look like: 

	qotd   stream  tcp     nowait  root    /bin/qotdd      qotd -i

					Starting from inetd means that perl
					must recompile qotdd every time a
					client connects, which can be a large 
					slowdown.

	-p, --port port:		Listen on an alternate port instead of
					17.  Meaningless in inetd mode.
EOF
;
	exit 0;
}

use Getopt::Long;

$errors = &GetOptions("version|v" => \&dispver, 
"command|c=s" => \$cmd, 
"inetd|i" => \$inetd, 
"port|p" => \$port, 
"help|h|usage|?" => \&help);

if($ARGV[0]) {
	print "Unknown option: $ARGV[0]\n";
	$errors = 0;
}
if(!$errors) {
	print "Try qotdd --help if you need help.\n";
	exit 1;
}

$inetd = 0 unless $inetd; #squelch -w
$port = 17 unless $port;

if ($inetd != 1) {
	use Socket;
	use POSIX;

	#Code that removes need for &
		$pid = fork;
		exit if $pid;
		die "Couldn't fork: $!" unless defined($pid);
	
		POSIX::setsid() or die "Can't start a new session: $!";
		sub signal_handler {
			close SERVER; 
			exit 1;
		}
		$SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&signal_handler; #trap fatal sigs

	#Code to restart on SIGHUP
		sub phoenix { 
			close SERVER;	exec($0, @ARGV);
		}
		$SIG{HUP} = \&phoenix;

	#Code to handle incoming connections
		socket(SERVER, PF_INET, SOCK_STREAM, getprotobyname('tcp'));

		setsockopt(SERVER, SOL_SOCKET, SO_REUSEADDR, 1);

		$my_addr = sockaddr_in($port, INADDR_ANY);
		bind(SERVER, $my_addr) or die "Couldn't bind: $!\n";

		listen(SERVER, SOMAXCONN) or die "Couldn't listen: $!\n";

		while(accept(CLIENT, SERVER)) {
			print CLIENT `$cmd`;
		}

		close SERVER;
} else { #inetd == 1
	print `$cmd`;
}
